# CustomRTOS
An RTOS made for STM32 microcontrollers, specifically tested on a STM32F411RE Nucleo Board.

## Project Directory
```
  .
  |-- chip_headers/CMSIS      # CMSIS, with only the required STM32 libraries and ARM v7 compiler files
  |-- GCC_STM32CubeIDE/RTOS   # Root directory of the actual RTOS, made in STM32CubeIDE
  |   |-- chip_headers        # Local copy of CMSIS
  |   |-- Debug               # Debug files autogenerated by CubeIDE
  |   |-- Inc                 # Header files
  |   |-- Src
  |   │   |-- led.c           # LED driver
  |   │   |-- main.c          # Main executable
  |   │   |-- osKernel.c      # RTOS implementation
  |   │   |-- syscalls.c      # STM32F4 syscalls, autogenerated by CubeIDE
  |   │   |-- sysmem.c        # STM32F4 memory initialization, autogenerated by CubeIDE
  |   │   |-- timebase.c      # Basic ddtimer handler for SysTick, not used in osKernel
  |   │   |-- uart.c          # UART communcation setup (for debugging)
  |   |-- Startup             # Startup routine autogenerated by CubeIDE
  |   |-- ... .launch         # Individual binary launch routines autogenerated by CubeIDE
  |-- ... .pdf                # User manuals, data sheets for the hardware (development board, MCU, Cortex M4)
  |-- README.md
```
## Usage and Demos

### LED and UART drivers.
The LED and UART drivers are implemented mostly for debugging purposes. The process to create the LED driver could be generalized to handle any GPIO input/output.

https://github.com/twilkhoo/CustomRTOS/assets/30396273/c6e4262e-5f35-4ced-aa18-5fbc576f43f8

### Round Robin Scheduler
A round robin scheduler is at the core of this kernel. Currently, the scheduler supports RR context switching three threads, with a specified time quanta. The task profiler indicates the progression of each task evenly.

https://github.com/twilkhoo/CustomRTOS/assets/30396273/f5eb4a8f-b86d-45d1-bc57-c707bc12b7f7

### Semaphore 

API
Naturally, multithreading could imply generating race conditions. For example, two tasks printing different things through UART with a small time quanta (2ms) are racing to use the resource (the serial communication bus), so the output isn't as desired, as shown below.

https://github.com/twilkhoo/CustomRTOS/assets/30396273/5576e0d2-ec88-4ec5-9931-c5c92819f481

Semaphores can solve this, with the current implementation being a spinlock semaphore. A semaphore spins (`osSemaphoreWait`) until it is able to use the resource, which is when it posts (`osSemaphorePost`).

https://github.com/twilkhoo/CustomRTOS/assets/30396273/714813b3-e51d-4929-8791-83ed57456b83

## Next Steps
There are other things left to implement, which include:
- Add priority to RR scheduler.
There are different ways to do this. The easiest way to give more resource time to a higher priority task would be to have priority as a multiplier to quanta; higher priority directly implies a task runs for longer. This, however, is bad for average response time (lower priority tasks would take longer to begin) and could also increase latency, overall not being a fair solution. A more common alternative is to have higher priority tasks run more often. FreeBSD implements this a [multilevel feedback queue](https://papers.freebsd.org/2004/mckusick-thread_scheduler.files/mckusick-thread_scheduler-paper.pdf), which organizes groups of priorities into their own queues and does RR on them, allowing higher priority tasks to run more often.

- Add dynamic priority to RR scheduler.
This is a followup to the last point; it would be desirable for tasks not only to have priorities, but to also be able to change them at run time.

- Add wait channels.
The semaphore API currently implements busy waiting- a simple implementation that isn't too efficient since a thread would just be spinning until it obtains the resources. Wait channels are a more desirable solution, putting a thread that doesn't have a resource onto a wait channel so it can be notified by the currently running thread of when it's ready to relinquish the resource.

- Add mutexes and condition variables.
Basically, just implement all of `pthread`s. This would be a nice add-on after we have wait channels.

## Resources
To have some context on how to work with this MCU, and how to develop an RTOS, I used the following sources:

- [DigiKey's Intro to RTOS (FreeRTOS)](https://youtube.com/playlist?list=PLEBQazB0HUyQ4hAPU1cJED6t3DU0h34bz&si=dXVZqiqUQdNZ75k3)
- [Israel Gbati's RTOS on ARM Tutorial](https://www.udemy.com/course/rtos-building-from-ground-up-on-arm-processors/)
- The four pdfs in this repo- STM32F411 DS/UM, Cortex M4 UM, Nucleo UM
